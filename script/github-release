#!/bin/bash
#
# Create a GitHub Release for Flynn
#
# This script should be run AFTER building Flynn with script/build-flynn.
# It packages the built binaries and creates a GitHub release.
#
# Usage:
#   ./script/github-release                           # Auto-generate version
#   ./script/github-release --version v20240127.0    # Specific version
#   ./script/github-release --dry-run                # Show what would be uploaded
#
# Prerequisites:
#   - Flynn must be built (run script/build-flynn first)
#   - GitHub CLI (gh) must be installed and authenticated
#   - Changes should be committed (for accurate release notes)
#

set -eo pipefail

ROOT="$(cd "$(dirname "$0")/.." && pwd)"
source "${ROOT}/script/lib/ui.sh"

# Defaults
VERSION=""
GITHUB_REPO="${FLYNN_GITHUB_REPO:-randy-girard/flynn}"
DRY_RUN=false
BUILD_DIR="${ROOT}/build/bin"

usage() {
  cat <<USAGE >&2
usage: $0 [OPTIONS]

Create a GitHub Release for Flynn.

OPTIONS:
  -h, --help                  Show this message
  --version VERSION           Version for release (e.g., v20240127.0)
  --github-repo OWNER/REPO    GitHub repository [default: randy-girard/flynn]
  --dry-run                   Show what would be uploaded without creating release
USAGE
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --version)
      VERSION="$2"
      shift 2
      ;;
    --github-repo)
      GITHUB_REPO="$2"
      shift 2
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
  esac
done

# Check for GitHub CLI
if ! command -v gh &> /dev/null; then
  fail "GitHub CLI (gh) is not installed. Install it with: apt install gh"
fi

# Check if authenticated
if ! gh auth status &> /dev/null; then
  fail "Not authenticated with GitHub. Run: gh auth login"
fi

# Get version from flynn-host if not provided
if [[ -z "${VERSION}" ]]; then
  FLYNN_HOST="${BUILD_DIR}/flynn-host"
  if [[ -x "${FLYNN_HOST}" ]]; then
    VERSION=$("${FLYNN_HOST}" version 2>/dev/null | head -n1)
    # Strip any commit suffix (e.g., v20260129.0-abc1234 -> v20260129.0)
    VERSION="${VERSION%%-*}"
    if [[ -n "${VERSION}" && "${VERSION}" != "dev" ]]; then
      info "Using version from flynn-host: ${VERSION}"
    else
      VERSION=""
    fi
  fi
fi

# Fall back to auto-generating version if still not set
if [[ -z "${VERSION}" ]]; then
  # Format: vYYYYMMDD.N where N is incremented if multiple releases on same day
  DATE_PREFIX="v$(date +%Y%m%d)"
  # Check for existing tags with today's date
  LATEST_TODAY=$(git tag -l "${DATE_PREFIX}.*" 2>/dev/null | sort -V | tail -n1)
  if [[ -n "${LATEST_TODAY}" ]]; then
    # Extract the iteration number and increment
    ITERATION="${LATEST_TODAY##*.}"
    VERSION="${DATE_PREFIX}.$((ITERATION + 1))"
  else
    VERSION="${DATE_PREFIX}.0"
  fi
  info "Auto-generated version: ${VERSION}"
fi

info "Creating GitHub Release ${VERSION} for ${GITHUB_REPO}"

# Verify build artifacts exist
if [[ ! -d "${BUILD_DIR}" ]]; then
  fail "Build directory not found: ${BUILD_DIR}\nRun 'script/build-flynn --version ${VERSION}' first!"
fi

if [[ ! -f "${BUILD_DIR}/flynn-host" ]]; then
  fail "flynn-host binary not found in ${BUILD_DIR}\nRun 'script/build-flynn --version ${VERSION}' first!"
fi

# Create release artifacts directory
RELEASE_DIR="/tmp/flynn-github-release-${VERSION}"
rm -rf "${RELEASE_DIR}"
mkdir -p "${RELEASE_DIR}"

# Package binaries (gzipped)
info "Packaging binaries..."
BINARIES=(
  "flynn-host"
  "flynn-init"
  "flynn-linux-amd64"
  "flynn-linux-386"
  "flynn-darwin-amd64"
  "flynn-darwin-arm64"
  "flynn-windows-amd64.exe"
)

for bin in "${BINARIES[@]}"; do
  if [[ -f "${BUILD_DIR}/${bin}" ]]; then
    gzip -c "${BUILD_DIR}/${bin}" > "${RELEASE_DIR}/${bin}.gz"
    echo "  - ${bin}.gz"
  fi
done

# Package manifests (gzipped) if they exist
info "Packaging manifests..."
MANIFESTS_DIR="${ROOT}/build/manifests"
for manifest in bootstrap-manifest.json images.json; do
  if [[ -f "${MANIFESTS_DIR}/${manifest}" ]]; then
    gzip -c "${MANIFESTS_DIR}/${manifest}" > "${RELEASE_DIR}/${manifest}.gz"
    echo "  - ${manifest}.gz"
  fi
done

# Package container image manifests if they exist
info "Packaging image manifests..."
IMAGE_DIR="${ROOT}/build/image"
if [[ -d "${IMAGE_DIR}" ]] && [[ -n "$(ls -A ${IMAGE_DIR}/*.json 2>/dev/null)" ]]; then
  mkdir -p "${RELEASE_DIR}/images"
  cp "${IMAGE_DIR}/"*.json "${RELEASE_DIR}/images/" 2>/dev/null || true
  # Create a tarball of all image manifests
  (cd "${RELEASE_DIR}" && tar czf "images.tar.gz" images/)
  echo "  - images.tar.gz ($(ls ${RELEASE_DIR}/images/*.json 2>/dev/null | wc -l) manifests)"
  rm -rf "${RELEASE_DIR}/images"
else
  echo "  (no image manifests found in ${IMAGE_DIR})"
fi

# Package squashfs layers if they exist (as individual files - GitHub has 2GB limit)
info "Packaging layers..."
LAYER_CACHE="/var/lib/flynn/layer-cache"
LAYER_COUNT=0

if [[ -d "${LAYER_CACHE}" ]] && [[ -n "$(ls -A ${LAYER_CACHE}/*.squashfs 2>/dev/null)" ]]; then
  for layer_file in "${LAYER_CACHE}"/*.squashfs "${LAYER_CACHE}"/*.json; do
    if [[ -f "$layer_file" ]]; then
      layer_name=$(basename "$layer_file")
      cp "$layer_file" "${RELEASE_DIR}/${layer_name}"
      LAYER_COUNT=$((LAYER_COUNT + 1))
    fi
  done
  echo "  - ${LAYER_COUNT} layer files"
else
  echo "  (no layers found in ${LAYER_CACHE})"
fi

# Copy install scripts
cp "${ROOT}/script/install-flynn-github" "${RELEASE_DIR}/install-flynn-github"
cp "${ROOT}/script/install-flynn-cli" "${RELEASE_DIR}/install-flynn-cli"

# Generate checksums (including layer files)
info "Generating checksums..."
(cd "${RELEASE_DIR}" && find . -type f \( -name "*.gz" -o -name "*.squashfs" -o -name "*.json" -o -name "install-flynn-*" \) | xargs sha512sum > checksums.sha512 2>/dev/null || true)

info "Release artifacts:"
ls -lah "${RELEASE_DIR}"
if [[ ${LAYER_COUNT} -gt 0 ]]; then
  echo "  (includes ${LAYER_COUNT} layer files)"
fi

# Generate release notes from commits since last release
info "Generating release notes from commits..."

# Fetch all tags from remote to ensure we have the latest
echo "  Fetching tags from remote..."
git fetch --tags --force 2>/dev/null || true

# Get the previous release tag (most recent tag before this one)
# First, get all tags sorted by version, then find the one before the current version
if git rev-parse "${VERSION}" >/dev/null 2>&1; then
  # Tag exists, get the previous one
  PREVIOUS_TAG=$(git tag -l 'v*' | sort -V | grep -B1 "^${VERSION}$" | head -n1)
  # If grep returned the same tag (no previous), clear it
  if [[ "${PREVIOUS_TAG}" == "${VERSION}" ]]; then
    PREVIOUS_TAG=""
  fi
else
  # Tag doesn't exist yet, get the most recent tag
  PREVIOUS_TAG=$(git tag -l 'v*' | sort -V | tail -n1)
fi

if [[ -n "${PREVIOUS_TAG}" ]]; then
  echo "  Previous release: ${PREVIOUS_TAG}"
  COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
  COMMIT_COUNT=$(git rev-list --count "${COMMIT_RANGE}" 2>/dev/null || echo "0")
  echo "  Found ${COMMIT_COUNT} commits since ${PREVIOUS_TAG}"
else
  echo "  No previous tag found, using recent commits"
  COMMIT_RANGE="HEAD~20..HEAD"
  COMMIT_COUNT="recent"
fi

# Categorize commits by conventional commit type
FEAT_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^feat" "${COMMIT_RANGE}" 2>/dev/null || echo "")
FIX_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^fix" "${COMMIT_RANGE}" 2>/dev/null || echo "")
CHORE_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^chore" "${COMMIT_RANGE}" 2>/dev/null || echo "")
DOCS_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^docs" "${COMMIT_RANGE}" 2>/dev/null || echo "")
REFACTOR_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^refactor" "${COMMIT_RANGE}" 2>/dev/null || echo "")
PERF_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^perf" "${COMMIT_RANGE}" 2>/dev/null || echo "")
TEST_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^test" "${COMMIT_RANGE}" 2>/dev/null || echo "")
BUILD_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^build" "${COMMIT_RANGE}" 2>/dev/null || echo "")
CI_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^ci" "${COMMIT_RANGE}" 2>/dev/null || echo "")
# Other commits (don't match any conventional prefix)
OTHER_COMMITS=$(git log --pretty=format:"- %s (%h)" "${COMMIT_RANGE}" 2>/dev/null | grep -v -E "^- (feat|fix|chore|docs|refactor|perf|test|build|ci)" || echo "")

# Build categorized release notes
RELEASE_NOTES=""
if [[ -n "${FEAT_COMMITS}" ]]; then
  RELEASE_NOTES+="### âœ¨ Features

${FEAT_COMMITS}

"
fi
if [[ -n "${FIX_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ› Bug Fixes

${FIX_COMMITS}

"
fi
if [[ -n "${PERF_COMMITS}" ]]; then
  RELEASE_NOTES+="### âš¡ Performance

${PERF_COMMITS}

"
fi
if [[ -n "${REFACTOR_COMMITS}" ]]; then
  RELEASE_NOTES+="### â™»ï¸ Refactoring

${REFACTOR_COMMITS}

"
fi
if [[ -n "${DOCS_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ“š Documentation

${DOCS_COMMITS}

"
fi
if [[ -n "${TEST_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ§ª Tests

${TEST_COMMITS}

"
fi
if [[ -n "${BUILD_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ—ï¸ Build

${BUILD_COMMITS}

"
fi
if [[ -n "${CI_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ‘· CI

${CI_COMMITS}

"
fi
if [[ -n "${CHORE_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ”§ Chores

${CHORE_COMMITS}

"
fi
if [[ -n "${OTHER_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ“¦ Other Changes

${OTHER_COMMITS}

"
fi

# Fallback if no commits found
if [[ -z "${RELEASE_NOTES}" ]]; then
  RELEASE_NOTES="No changes recorded."
fi

# Dry run - just show what would be uploaded
if $DRY_RUN; then
  info "DRY RUN - Would create release ${VERSION} with the following artifacts:"
  echo ""
  echo "Release artifacts:"
  ls -lah "${RELEASE_DIR}"
  if [[ -d "${LAYERS_DIR}" ]] && [[ -n "$(ls -A ${LAYERS_DIR} 2>/dev/null)" ]]; then
    echo ""
    echo "Layer files:"
    ls -lah "${LAYERS_DIR}"
  fi
  echo ""
  echo "Release notes:"
  echo "---"
  echo "${RELEASE_NOTES}"
  echo "---"
  rm -rf "${RELEASE_DIR}"
  exit 0
fi

# Check if release already exists
if gh release view "${VERSION}" --repo "${GITHUB_REPO}" &> /dev/null; then
  echo "  Release ${VERSION} exists, updating..."
  gh release delete "${VERSION}" --repo "${GITHUB_REPO}" --yes || true
fi

# Build list of files to upload
UPLOAD_FILES=()
for f in "${RELEASE_DIR}"/*.gz "${RELEASE_DIR}"/*.sha512 "${RELEASE_DIR}"/install-flynn-*; do
  [[ -f "$f" ]] && UPLOAD_FILES+=("$f")
done

# Add layer files (squashfs and json)
for f in "${RELEASE_DIR}"/*.squashfs "${RELEASE_DIR}"/*.json; do
  [[ -f "$f" ]] && UPLOAD_FILES+=("$f")
done

# Create the release
info "Pushing to GitHub Release ${VERSION}..."
gh release create "${VERSION}" \
  --repo "${GITHUB_REPO}" \
  --title "Flynn ${VERSION}" \
  --notes "## Flynn ${VERSION}

**Full Changelog**: ${PREVIOUS_TAG:-initial}...${VERSION}

${RELEASE_NOTES}
---

## Install Flynn CLI

Install the Flynn command-line interface on your local machine (Linux or macOS):

\`\`\`bash
curl -fsSL https://raw.githubusercontent.com/${GITHUB_REPO}/main/script/install-flynn-cli | sudo bash
\`\`\`

Or install a specific version:

\`\`\`bash
curl -fsSL https://raw.githubusercontent.com/${GITHUB_REPO}/main/script/install-flynn-cli | sudo bash -s -- --version ${VERSION}
\`\`\`

## Install Flynn Host (Server)

Install Flynn on an Ubuntu server (24.04):

\`\`\`bash
curl -fsSL https://github.com/${GITHUB_REPO}/releases/download/${VERSION}/install-flynn-github | sudo bash
\`\`\`

## Artifacts

### CLI Binaries
| Binary | Platform |
|--------|----------|
| flynn-linux-amd64.gz | Linux (x86_64) |
| flynn-linux-386.gz | Linux (x86) |
| flynn-darwin-amd64.gz | macOS (Intel) |
| flynn-darwin-arm64.gz | macOS (Apple Silicon) |
| flynn-windows-amd64.exe.gz | Windows (x86_64) |

### Server Binaries
| Binary | Description |
|--------|-------------|
| flynn-host.gz | Flynn host daemon |
| flynn-init.gz | Flynn init binary |

### Other
| File | Description |
|------|-------------|
| install-flynn-cli | CLI installer script |
| install-flynn-github | Server installer script |
| checksums.sha512 | SHA512 checksums for all artifacts |
" \
  "${UPLOAD_FILES[@]}"

info "GitHub Release ${VERSION} created successfully!"
echo "     https://github.com/${GITHUB_REPO}/releases/tag/${VERSION}"

# Cleanup
rm -rf "${RELEASE_DIR}"
