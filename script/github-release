#!/bin/bash
#
# Create a GitHub Release for Flynn
#
# This script should be run AFTER building Flynn with build.sh and committing your changes.
# It will use the current commit information to generate release notes.
#
# Usage:
#   ./script/github-release                           # Auto-generate version
#   ./script/github-release --version v20240127.0    # Specific version
#   ./script/github-release --dry-run                # Show what would be uploaded
#
# Prerequisites:
#   - Flynn must be built (run ./build.sh first)
#   - GitHub CLI (gh) must be installed and authenticated
#   - Changes should be committed (for accurate release notes)
#

set -eo pipefail

ROOT="$(cd "$(dirname "$0")/.." && pwd)"
source "${ROOT}/script/lib/ui.sh"

# Defaults
VERSION=""
GITHUB_REPO="${FLYNN_GITHUB_REPO:-randy-girard/flynn}"
DRY_RUN=false
TUF_STAGED="${ROOT}/go-tuf/repo/staged/targets"

usage() {
  cat <<USAGE >&2
usage: $0 [OPTIONS]

Create a GitHub Release for Flynn.

OPTIONS:
  -h, --help              Show this message
  --version VERSION       Version for release (e.g., v20240127.0)
  --github-repo OWNER/REPO  GitHub repository [default: randy-girard/flynn]
  --dry-run               Show what would be uploaded without creating release
USAGE
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h|--help)
      usage
      exit 0
      ;;
    --version)
      VERSION="$2"
      shift 2
      ;;
    --github-repo)
      GITHUB_REPO="$2"
      shift 2
      ;;
    --dry-run)
      DRY_RUN=true
      shift
      ;;
    *)
      echo "Unknown option: $1"
      usage
      exit 1
      ;;
  esac
done

# Check for GitHub CLI
if ! command -v gh &> /dev/null; then
  fail "GitHub CLI (gh) is not installed. Install it with: apt install gh"
fi

# Check if authenticated
if ! gh auth status &> /dev/null; then
  fail "Not authenticated with GitHub. Run: gh auth login"
fi

# Generate version if not provided
if [[ -z "${VERSION}" ]]; then
  # Format: vYYYYMMDD.N where N is incremented if multiple releases on same day
  DATE_PREFIX="v$(date +%Y%m%d)"
  # Check for existing tags with today's date
  LATEST_TODAY=$(git tag -l "${DATE_PREFIX}.*" 2>/dev/null | sort -V | tail -n1)
  if [[ -n "${LATEST_TODAY}" ]]; then
    # Extract the iteration number and increment
    ITERATION="${LATEST_TODAY##*.}"
    VERSION="${DATE_PREFIX}.$((ITERATION + 1))"
  else
    VERSION="${DATE_PREFIX}.0"
  fi
  info "Auto-generated version: ${VERSION}"
fi

info "Creating GitHub Release ${VERSION} for ${GITHUB_REPO}"

# Verify build artifacts exist
if [[ ! -d "${TUF_STAGED}" ]]; then
  fail "TUF staged directory not found: ${TUF_STAGED}\nMake sure you've run ./build.sh first!"
fi

# Create release artifacts directory
RELEASE_DIR="/tmp/flynn-github-release-${VERSION}"
rm -rf "${RELEASE_DIR}"
mkdir -p "${RELEASE_DIR}"

# Package binaries (gzipped)
info "Packaging binaries..."
for bin in flynn-host flynn-init flynn-linux-amd64 flynn-linux-386 flynn-darwin-amd64; do
  if [[ -f "${TUF_STAGED}/${bin}.gz" ]]; then
    cp "${TUF_STAGED}/${bin}.gz" "${RELEASE_DIR}/${bin}.gz"
    echo "  - ${bin}.gz"
  elif [[ -f "${ROOT}/build/bin/${bin}" ]]; then
    gzip -c "${ROOT}/build/bin/${bin}" > "${RELEASE_DIR}/${bin}.gz"
    echo "  - ${bin}.gz (from build/bin)"
  fi
done

# Package manifests (gzipped)
info "Packaging manifests..."
for manifest in bootstrap-manifest.json images.json; do
  # Look in versioned directory first
  if [[ -f "${TUF_STAGED}/${VERSION}/${manifest}.gz" ]]; then
    cp "${TUF_STAGED}/${VERSION}/${manifest}.gz" "${RELEASE_DIR}/${manifest}.gz"
    echo "  - ${manifest}.gz"
  elif [[ -f "${ROOT}/build/manifests/${manifest}" ]]; then
    gzip -c "${ROOT}/build/manifests/${manifest}" > "${RELEASE_DIR}/${manifest}.gz"
    echo "  - ${manifest}.gz (from build/manifests)"
  fi
done

# Package container image manifests
info "Packaging image manifests..."
if [[ -d "${TUF_STAGED}/images" ]] && [[ -n "$(ls -A ${TUF_STAGED}/images/*.json 2>/dev/null)" ]]; then
  mkdir -p "${RELEASE_DIR}/images"
  cp -r "${TUF_STAGED}/images/"*.json "${RELEASE_DIR}/images/" 2>/dev/null || true
  # Create a tarball of all image manifests
  (cd "${TUF_STAGED}" && tar czf "${RELEASE_DIR}/images.tar.gz" images/)
  echo "  - images.tar.gz [from TUF staged]"
elif [[ -d "${ROOT}/build/image" ]] && [[ -n "$(ls -A ${ROOT}/build/image/*.json 2>/dev/null)" ]]; then
  # Fallback: use image manifests from build/image directory
  echo "  (TUF staged images not found, using build/image)"
  mkdir -p "${RELEASE_DIR}/images"
  cp "${ROOT}/build/image/"*.json "${RELEASE_DIR}/images/" 2>/dev/null || true
  # Create a tarball of all image manifests
  (cd "${RELEASE_DIR}" && tar czf "images.tar.gz" images/)
  echo "  - images.tar.gz [from build/image]"
else
  echo "  WARNING: No image manifests found in ${TUF_STAGED}/images or build/image"
fi

# Package squashfs layers (as individual files, not tar - GitHub has 2GB limit)
info "Packaging layers..."
LAYERS_DIR="${RELEASE_DIR}/layers"
mkdir -p "${LAYERS_DIR}"
LAYER_COUNT=0

if [[ -d "${TUF_STAGED}/layers" ]] && [[ -n "$(ls -A ${TUF_STAGED}/layers 2>/dev/null)" ]]; then
  # Copy layers from TUF staged directory
  for layer_file in "${TUF_STAGED}/layers"/*; do
    if [[ -f "$layer_file" ]]; then
      cp "$layer_file" "${LAYERS_DIR}/"
      LAYER_COUNT=$((LAYER_COUNT + 1))
    fi
  done
  echo "  - ${LAYER_COUNT} layer files [from TUF staged]"
elif [[ -d "/var/lib/flynn/layer-cache" ]] && [[ -n "$(ls -A /var/lib/flynn/layer-cache/*.squashfs 2>/dev/null)" ]]; then
  # Fallback: copy layers from the layer-cache directory
  echo "  (TUF staged layers not found, using layer-cache)"
  for layer_file in /var/lib/flynn/layer-cache/*.squashfs /var/lib/flynn/layer-cache/*.json; do
    if [[ -f "$layer_file" ]]; then
      cp "$layer_file" "${LAYERS_DIR}/"
      LAYER_COUNT=$((LAYER_COUNT + 1))
    fi
  done
  echo "  - ${LAYER_COUNT} layer files [from layer-cache]"
else
  echo "  WARNING: No layers found in ${TUF_STAGED}/layers or /var/lib/flynn/layer-cache"
fi

# Show layer sizes
if [[ ${LAYER_COUNT} -gt 0 ]]; then
  echo "  Layer files:"
  ls -lh "${LAYERS_DIR}" | tail -n +2 | while read line; do
    echo "    $line"
  done
  echo "  Total: $(du -sh ${LAYERS_DIR} | cut -f1)"
fi

# Copy install scripts
cp "${ROOT}/script/install-flynn-github" "${RELEASE_DIR}/install-flynn-github"
cp "${ROOT}/script/install-flynn-cli" "${RELEASE_DIR}/install-flynn-cli"

# Generate checksums (including layer files)
info "Generating checksums..."
(cd "${RELEASE_DIR}" && find . -type f \( -name "*.gz" -o -name "*.squashfs" -o -name "*.json" -o -name "install-flynn-*" \) | xargs sha512sum > checksums.sha512 2>/dev/null || true)

info "Release artifacts:"
ls -lah "${RELEASE_DIR}"
if [[ -d "${LAYERS_DIR}" ]]; then
  echo "===> Layer files (${LAYER_COUNT} files):"
  du -sh "${LAYERS_DIR}"
fi

# Generate release notes from commits since last release
info "Generating release notes from commits..."
PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || echo "")
if [[ -n "${PREVIOUS_TAG}" ]]; then
  echo "  Previous release: ${PREVIOUS_TAG}"
  COMMIT_RANGE="${PREVIOUS_TAG}..HEAD"
  COMMIT_COUNT=$(git rev-list --count "${COMMIT_RANGE}" 2>/dev/null || echo "0")
  echo "  Found ${COMMIT_COUNT} commits since ${PREVIOUS_TAG}"
else
  echo "  No previous tag found, using recent commits"
  COMMIT_RANGE="HEAD~20..HEAD"
  COMMIT_COUNT="recent"
fi

# Categorize commits by conventional commit type
FEAT_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^feat" "${COMMIT_RANGE}" 2>/dev/null || echo "")
FIX_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^fix" "${COMMIT_RANGE}" 2>/dev/null || echo "")
CHORE_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^chore" "${COMMIT_RANGE}" 2>/dev/null || echo "")
DOCS_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^docs" "${COMMIT_RANGE}" 2>/dev/null || echo "")
REFACTOR_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^refactor" "${COMMIT_RANGE}" 2>/dev/null || echo "")
PERF_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^perf" "${COMMIT_RANGE}" 2>/dev/null || echo "")
TEST_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^test" "${COMMIT_RANGE}" 2>/dev/null || echo "")
BUILD_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^build" "${COMMIT_RANGE}" 2>/dev/null || echo "")
CI_COMMITS=$(git log --pretty=format:"- %s (%h)" --grep="^ci" "${COMMIT_RANGE}" 2>/dev/null || echo "")
# Other commits (don't match any conventional prefix)
OTHER_COMMITS=$(git log --pretty=format:"- %s (%h)" "${COMMIT_RANGE}" 2>/dev/null | grep -v -E "^- (feat|fix|chore|docs|refactor|perf|test|build|ci)" || echo "")

# Build categorized release notes
RELEASE_NOTES=""
if [[ -n "${FEAT_COMMITS}" ]]; then
  RELEASE_NOTES+="### âœ¨ Features

${FEAT_COMMITS}

"
fi
if [[ -n "${FIX_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ› Bug Fixes

${FIX_COMMITS}

"
fi
if [[ -n "${PERF_COMMITS}" ]]; then
  RELEASE_NOTES+="### âš¡ Performance

${PERF_COMMITS}

"
fi
if [[ -n "${REFACTOR_COMMITS}" ]]; then
  RELEASE_NOTES+="### â™»ï¸ Refactoring

${REFACTOR_COMMITS}

"
fi
if [[ -n "${DOCS_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ“š Documentation

${DOCS_COMMITS}

"
fi
if [[ -n "${TEST_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ§ª Tests

${TEST_COMMITS}

"
fi
if [[ -n "${BUILD_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ—ï¸ Build

${BUILD_COMMITS}

"
fi
if [[ -n "${CI_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ‘· CI

${CI_COMMITS}

"
fi
if [[ -n "${CHORE_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ”§ Chores

${CHORE_COMMITS}

"
fi
if [[ -n "${OTHER_COMMITS}" ]]; then
  RELEASE_NOTES+="### ðŸ“¦ Other Changes

${OTHER_COMMITS}

"
fi

# Fallback if no commits found
if [[ -z "${RELEASE_NOTES}" ]]; then
  RELEASE_NOTES="No changes recorded."
fi

# Dry run - just show what would be uploaded
if $DRY_RUN; then
  info "DRY RUN - Would create release ${VERSION} with the following artifacts:"
  echo ""
  echo "Release artifacts:"
  ls -lah "${RELEASE_DIR}"
  if [[ -d "${LAYERS_DIR}" ]] && [[ -n "$(ls -A ${LAYERS_DIR} 2>/dev/null)" ]]; then
    echo ""
    echo "Layer files:"
    ls -lah "${LAYERS_DIR}"
  fi
  echo ""
  echo "Release notes:"
  echo "---"
  echo "${RELEASE_NOTES}"
  echo "---"
  rm -rf "${RELEASE_DIR}"
  exit 0
fi

# Check if release already exists
if gh release view "${VERSION}" --repo "${GITHUB_REPO}" &> /dev/null; then
  echo "  Release ${VERSION} exists, updating..."
  gh release delete "${VERSION}" --repo "${GITHUB_REPO}" --yes || true
fi

# Create the release with main artifacts first
info "Pushing to GitHub Release ${VERSION}..."
gh release create "${VERSION}" \
  --repo "${GITHUB_REPO}" \
  --title "Flynn ${VERSION}" \
  --notes "## Flynn ${VERSION}

**Full Changelog**: ${PREVIOUS_TAG:-initial}...${VERSION}

${RELEASE_NOTES}
---

## Install Flynn CLI

Install the Flynn command-line interface on your local machine (Linux or macOS):

\`\`\`bash
curl -fsSL https://raw.githubusercontent.com/${GITHUB_REPO}/main/script/install-flynn-cli | sudo bash
\`\`\`

Or install a specific version:

\`\`\`bash
curl -fsSL https://raw.githubusercontent.com/${GITHUB_REPO}/main/script/install-flynn-cli | sudo bash -s -- --version ${VERSION}
\`\`\`

## Install Flynn Host (Server)

Install Flynn on an Ubuntu server (24.04):

\`\`\`bash
curl -fsSL https://github.com/${GITHUB_REPO}/releases/download/${VERSION}/install-flynn-github | sudo bash
\`\`\`

## Artifacts

### CLI Binaries
- \`flynn-linux-amd64.gz\` - Flynn CLI (Linux x86_64)
- \`flynn-linux-386.gz\` - Flynn CLI (Linux x86)
- \`flynn-darwin-amd64.gz\` - Flynn CLI (macOS x86_64)

### Server Binaries
- \`flynn-host.gz\` - Flynn host daemon
- \`flynn-init.gz\` - Flynn init binary

### Manifests & Images
- \`bootstrap-manifest.json.gz\` - Bootstrap manifest
- \`images.json.gz\` - Images manifest
- \`images.tar.gz\` - Container image manifests
- \`layers/*.squashfs\` - Container image layers (individual files)

### Other
- \`install-flynn-cli\` - CLI installer script
- \`install-flynn-github\` - Server installer script
- \`checksums.sha512\` - SHA512 checksums for all artifacts
" \
  "${RELEASE_DIR}"/*.gz "${RELEASE_DIR}"/*.sha512 "${RELEASE_DIR}"/install-flynn-* 2>/dev/null || true

# Upload layer files separately (they can be large)
if [[ -d "${LAYERS_DIR}" ]] && [[ -n "$(ls -A ${LAYERS_DIR} 2>/dev/null)" ]]; then
  info "Uploading layer files..."
  for layer_file in "${LAYERS_DIR}"/*; do
    if [[ -f "$layer_file" ]]; then
      layer_name=$(basename "$layer_file")
      echo "  Uploading ${layer_name}..."
      gh release upload "${VERSION}" "$layer_file" --repo "${GITHUB_REPO}" --clobber || {
        echo "  WARNING: Failed to upload ${layer_name}"
      }
    fi
  done
fi

info "GitHub Release ${VERSION} created successfully!"
echo "     https://github.com/${GITHUB_REPO}/releases/tag/${VERSION}"

# Cleanup
rm -rf "${RELEASE_DIR}"
